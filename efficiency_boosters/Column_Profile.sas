/* ==========================================================================
	MACRO:		_ColumnProfile.sas
	PURPOSE:	Quality control:  Creates a column-by-column profile, 
				a summary table for any SAS dataset. Reports the 
				number of missing values, minimum and maximum values,
				and the number of distinct levels for each variable.
	WRITTEN BY:	Ann Nakamura
	DATE:		October 5, 2008 
	MODIFIED:	(AN): Replaced the %sysfunc(open()) method of counting 
				observations with a sql statement to prevent locking of
				datasets. 
				(AN): Appended the input dataset name to the SUMMARY 
				file created in the work directory. 
				(AN): 10/24/2017: After the SAS PROC CONTENTS output is created,
				changed variables called 'NAME' to _NAME_ to prevent
				processing errors when a table has a variable called 
				'NAME'. 
   =========================================================================== */

%MACRO Column_Profile(DTASET);
%put NOTE- '********** Macro %Column_profile invoked.';
%put NOTE- '********** Author: Anakamur October 5, 2008.';
%put NOTE- '********** Use for quality control - create a column-by-column profile. ';
%put NOTE- '********** Parameter: SAS dataset name';

%put NOTE- "********** I= &I ";

%GLOBAL NUMOBS;

/* Peel off the libname assignment, if any. */

%IF %SCAN(&DTASET,2,'.') NE  %THEN %DO;
	%LET DbShort = %SCAN(&DTASET,2,'.'); /* If there's a libname, use the dataset name*/
	%END;
%ELSE %DO;
	%LET DbShort = &DTASET;
	%END;

PROC CONTENTS DATA=&DTASET NODETAILS NOPRINT OUT=__&DBshort; QUIT;RUN; 

* Number of variables in the dataset will be represented by the macro, &NVARS;
	PROC SQL;
		SELECT COUNT(*) INTO: Nvars FROM __&DBshort; QUIT; 

%PUT %sysfunc(repeat(%str(.),70))&NVARS;

* Number of observations in the dataset will be represented by the macro, &NumObs;
	PROC SQL;
		SELECT COUNT(*) INTO: NumObs FROM &DTASET; QUIT; 
/* This is the only place that the variable NAME is okay because it is 
   automatically generated by PROC CONTENTS. */

PROC SQL NOPRINT;
	SELECT NAME
	INTO: V1 THROUGH: V%EVAL(&NVARS) /* ordered list of variable names */
	FROM __&DBshort;
	QUIT; 

PROC SQL NOPRINT;
	SELECT TYPE
	INTO: TYP1 THROUGH: TYP%EVAL(&NVARS) /* ordered list of variable types */
	FROM __&DBshort;
	QUIT; 

PROC SQL ;
	SELECT LABEL
	INTO: LABEL1 THROUGH: LABEL%EVAL(&NVARS) /* ordered list of variable types */
	FROM __&DBshort;
	QUIT; 

* Create an empty dataset shell to hold data output in the proc append
  statement below;
DATA SUMMARY;
	LENGTH _NAME_ $75.;	 	LABEL _NAME_ ='VARIABLE NAME';
	LENGTH MINIMUM $75.; 	LABEL MINIMUM = 'MINIMUM VALUE';
	LENGTH MAXIMUM $75.; 	LABEL MAXIMUM ='MAXIMUM VALUE';
	FORMAT BLANKS 8.0;	 	LABEL BLANKS = 'MISSING';	
	FORMAT NONBLANKS 8.0; 	LABEL NONBLANKS='NOT MISSING'; 
	FORMAT LEVELS 8.0;	 	LABEL LEVELS = 'DISTINCT VALUES';	
	
	LENGTH VARIABLE_LABEL $300;
	FORMAT HASALPHA PERCENT8.2; LABEL HASALPHA = 'CONTAINS ALPHAS';
	FORMAT HASDIGIT PERCENT8.2; LABEL HASDIGIT = 'CONTAINS DIGITS';
	FORMAT STRING_RANGE $8.; 	LABEL STRING_RANGE='SHORTEST AND LONGEST STRING LENGTHS';
	FORMAT ALL_ALPHA PERCENT8.2; LABEL ALL_ALPHA = 'ALPHA CHARS ONLY';
	FORMAT ALL_DIGIT PERCENT8.2; LABEL ALL_DIGIT = 'DIGITS ONLY';

	FORMAT SUM_ZEROS 8.0; LABEL SUM_ZEROS = "Zeros";
	FORMAT SUM_ONES 8.0; LABEL SUM_ONES = "Ones";
	FORMAT SUM_OTHER 8.0; LABEL OTHER="Not 0/1";

	STOP;
	RUN; /* Empty dataset 'SUMMARY' created. */

/* ===============   PART I. VALUE RANGE AND BLANKS     ================= */

%DO I=1 %TO %EVAL(&NVARS);

%PUT;
%PUT "*********           PROCESSING VARIABLE: &&V&I *****************";
%PUT;

	DATA Strings%Eval(&I); 	SET SUMMARY; 	STOP; 	RUN; 
	DATA Numerics%Eval(&I); SET SUMMARY; 	STOP; 	RUN; 

	%IF "&&TYP&I" EQ "2" %THEN %DO; /* String variables */

		PROC SQL NOPRINT;
			CREATE TABLE Strings%EVAL(&I) AS 
				SELECT "&&V&I" AS _NAME_, 
						"&&LABEL&I" AS VARIABLE_LABEL, 
						MIN(&&V&I) AS MI, 
						MAX(&&V&I) AS MX, 
						NMISS(&&V&I) AS BLANKS,
						%EVAL(&NUMOBS)-NMISS(&&V&I) AS NONBLANKS,
		   				N(DISTINCT &&V&I) AS LEVELS, 

		   				/* String variables */
		   				SUM((ANYALPHA(TRIM(&&V&I)) GT 0))/%EVAL(&NUMOBS) FORMAT=PERCENT8.2 AS HASALPHA,
		   				PUT(MAX(LENGTH(TRIM(&&V&I))),8.) AS LONGEST_STR,
		   				PUT(MIN(LENGTH(TRIM(&&V&I))),8.) AS SHORTEST_STR,
		   				SUM((ANYDIGIT(TRIM(&&V&I)) GT 0))/%EVAL(&NUMOBS) FORMAT=PERCENT8.2 AS HASDIGIT,
		   				SUM(&&V&I NE '' AND COMPRESS(&&V&I,'ABCDEFGHIJKLMNOPQRSTUVWXYA%EVAL(&I).-/*-+)(&^%$#@!~` ') EQ '')/%EVAL(&NUMOBS) FORMAT=PERCENT8.2 AS ALL_ALPHA,
		   				SUM(&&V&I NE '' AND COMPRESS(&&V&I,'0123456789.-/*-+)(&^%$#@!~` ') EQ '')/%EVAL(&NUMOBS) FORMAT=PERCENT8.2 AS ALL_DIGIT,
		   				SUM(&&V&I EQ '1' OR &&V&I EQ 'Y') AS SUM_ONES,
		   				SUM(&&V&I EQ '0' OR &&V&I EQ 'N') AS SUM_ZEROS,
		   				SUM(NOT(&&V&I IN('1','Y')) AND NOT(&&V&I IN('0','N'))) AS SUM_OTHER
							FROM &DTASET
								GROUP BY _NAME_;
									QUIT;
		%END;

		%ELSE %DO;
			PROC SQL NOPRINT;
				CREATE TABLE Numerics%EVAL(&I) AS 
					SELECT "&&V&I" AS _NAME_, 
					"&&LABEL&I" AS VARIABLE_LABEL, 
					MIN(&&V&I) AS MI, 
					MAX(&&V&I) AS MX, 
					NMISS(&&V&I) AS BLANKS,
					%EVAL(&NUMOBS)-NMISS(&&V&I) AS NONBLANKS,
		   			N(DISTINCT &&V&I) AS LEVELS,
		   			/* String variables only*/
		   			. AS HASALPHA,
		  			 'N/A' AS LONGEST_STR,
		   			 'N/A' AS SHORTEST_STR,
		   			 0 AS HASDIGIT,
		   			 0 AS ALL_ALPHA,
		   			 0 AS ALL_DIGIT,
		   			 SUM(&&V&I EQ 1) AS SUM_ONES,
		   			 SUM(&&V&I EQ 0) AS SUM_ZEROS,
		   			 SUM(&&V&I NE 1 AND &&V&I NE 0) AS SUM_OTHER
						FROM &DTASET
							GROUP BY _NAME_;
								QUIT;
		%END; 


	DATA A%EVAL(&I); 
		LENGTH _NAME_ $75.;
		LENGTH VARIABLE_LABEL $300;
		SET Strings%EVAL(&I) Numerics%EVAL(&I);
		RUN; 

	/* Make sure there is enough room for the min and max strings */
	DATA A%EVAL(&I)(DROP=MI MX SHORTEST_STR LONGEST_STR);
		SET  A%EVAL(&I) ;

		MINIMUM=INPUT(MI,$75.);
		MAXIMUM=INPUT(MX,$75.);
		STRING_RANGE = COMPRESS(CAT(PUT(SHORTEST_STR,$3.),'-',PUT(LONGEST_STR,$3.)),' ');
		RUN;

	/* Append the table to the Summary Table; */
		PROC APPEND BASE=SUMMARY DATA=A%EVAL(&I) FORCE; RUN; 

%END;

/* ===============   PART II. CREATION OF SUMMARY TABLE  ================ */

PROC DATASETS NOLIST LIB=WORK;
	DELETE A1-A%EVAL(&NVARS); 
		QUIT; 

DATA _NULL_;
	SET __&DBshort;
	CALL SYMPUT("DTALABEL",MEMLABEL);
	RUN; 

	TITLE1 "Column Profile for: &DBshort";
	TITLE2 "Observations in dataset: &NumObs";

DATA 	sm_&DBshort;
	SET SUMMARY;
		pctBlank=blanks/(blanks+nonblanks);
		FORMAT pctBlank percent8.1;
		IF Variable_Label EQ _name_ THEN variable_label="None Assigned";
		RUN; 

	TITLE3 "Part I of II: Summary Overview";
	PROC PRINT DATA=sm_&DBshort; 
		VAR _name_ blanks pctBlank levels sum_zeros sum_ones sum_other;
		RUN;

	TITLE3 "Part I of II: Summary Detail";
	PROC PRINT DATA=sm_&DBshort; 
	VAR _name_ minimum maximum blanks pctBlank levels variable_label 
		hasAlpha HasDigit String_range all_alpha all_digit 
		sum_zeros sum_ones sum_other;
		RUN;

	PROC DATASETS LIB=WORK NODETAILS NOLIST ; 
	DELETE 	Strings1-Strings1500 summary
			Numerics1-Numerics1500; 
			QUIT; 
%put NOTE- "********** I= &I ";

%MEND;


